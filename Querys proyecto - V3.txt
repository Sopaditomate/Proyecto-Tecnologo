creación de la base:

CREATE DATABASE lovebites;
USE lovebites;

/////////////////////////////////////////////////////////////////////////////////
Creación de Tablas para las Entidades PRINCIPALES o FUERTES.

CREATE TABLE state (
    id_state INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Primary key of the state catalog',
    name VARCHAR(20) NOT NULL UNIQUE COMMENT 'Logical status (e.g., active, inactive, deleted)'
);


Tablas principales PSEUDOFUERTES


CREATE TABLE role (
    id_role INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Primary key for role catalog',
    name VARCHAR(20) NOT NULL UNIQUE COMMENT 'Role name: e.g., Admin, Client, etc.',
    id_state INT NOT NULL DEFAULT 1 COMMENT 'Reference to state catalog',
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 100000;

CREATE TABLE product_type (
    id_product_type INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Primary key for product types',
    name VARCHAR(30) NOT NULL COMMENT 'Name of the product type',
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 200000;

CREATE TABLE order_status (
    id_order_status INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Primary key for order statuses',
    name VARCHAR(20) NOT NULL COMMENT 'Order status name',
    description VARCHAR(40),
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 300000;

CREATE TABLE material_type (
    id_type_material INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Primary key for material types',
    name VARCHAR(50) COMMENT 'Name of the material type',
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 400000;

CREATE TABLE unit (
    id_unit INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Primary key for measurement units',
    name VARCHAR(20) NOT NULL COMMENT 'Unit name, e.g., kg, liters, units',
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 500000;

CREATE TABLE production_status (
    id_production_status INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Primary key for production statuses',
    name VARCHAR(15) NOT NULL COMMENT 'Status of production',
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 600000;


CREATE TABLE inventory_movement_type (
    id_inventory_movement_type INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(20) NOT NULL COMMENT 'e.g., IN, OUT',
    description VARCHAR(50),
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_state) REFERENCES state(id_state)
);

CREATE TABLE production_movement_type (
    id_production_movement_type INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(20) NOT NULL COMMENT 'e.g., START, FINISH, CANCEL',
    description VARCHAR(50),
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_state) REFERENCES state(id_state)
);


/////////////////////////////////////////////////////////////////////////////////

Creación de tablas para las entidades DEBILES


CREATE TABLE user_account (
    id_user INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Primary key for users',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT 'User email login',
    password VARCHAR(255) NOT NULL COMMENT 'Hashed password',
    reset_token VARCHAR(512) NULL COMMENT 'Reset password token',
    reset_token_expires DATETIME NULL COMMENT 'Reset password expiration datetime',
    verify_token VARCHAR(512) NULL COMMENT 'Email verification token',
    verified TINYINT(1) NOT NULL DEFAULT 0 COMMENT 'Indicate if the account is verified',
    is_logged_in BOOLEAN NOT NULL DEFAULT FALSE COMMENT 'Indicates if the user is currently logged in',
    id_state INT NOT NULL DEFAULT 1 COMMENT 'Reference to state catalog',
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 700000;


CREATE TABLE user_role (
    id_user INT NOT NULL,
    id_role INT NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    id_state INT NOT NULL DEFAULT 1,
    PRIMARY KEY (id_user, id_role),
    FOREIGN KEY (id_user) REFERENCES user_account(id_user),
    FOREIGN KEY (id_role) REFERENCES role(id_role),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
);


CREATE TABLE user_profile (
    id_profile INT AUTO_INCREMENT PRIMARY KEY,
    id_user INT NOT NULL UNIQUE,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    address VARCHAR(100) NOT NULL,
    phone VARCHAR(15) NOT NULL,
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_user) REFERENCES user_account(id_user),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 800000;

CREATE TABLE cart (
    id_cart INT AUTO_INCREMENT PRIMARY KEY,
    id_user INT NOT NULL,
    items JSON NOT NULL,
    updated_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    id_state INT NOT NULL DEFAULT 1,
    UNIQUE KEY unique_user_cart (id_user),
    FOREIGN KEY (id_user) REFERENCES user_account(id_user),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 3;


CREATE TABLE order_header (
    id_order INT AUTO_INCREMENT PRIMARY KEY,
    id_user INT NOT NULL,
    id_order_status INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    total_discount DECIMAL(10,2) DEFAULT 0,
    total_amount DECIMAL(10,2) NOT NULL,
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_user) REFERENCES user_account(id_user),
    FOREIGN KEY (id_order_status) REFERENCES order_status(id_order_status),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 1100000;

CREATE TABLE order_detail (
    id_order_detail INT AUTO_INCREMENT PRIMARY KEY,
    id_order INT NOT NULL,
    id_product INT NOT NULL,
    quantity INT NOT NULL CHECK (quantity >= 0),
    final_price DECIMAL(10,2) NOT NULL CHECK (final_price >= 0),
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_order) REFERENCES order_header(id_order),
    FOREIGN KEY (id_product) REFERENCES product(id_product),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 1300000;

CREATE TABLE raw_material (
    id_material INT AUTO_INCREMENT PRIMARY KEY,
    id_material_type INT NOT NULL,
    name VARCHAR(50) NOT NULL,
    description VARCHAR(254),
    id_unit INT NOT NULL,
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_material_type) REFERENCES material_type(id_type_material),
    FOREIGN KEY (id_unit) REFERENCES unit(id_unit),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 1400000;

CREATE TABLE inventory (
    id_inventory INT AUTO_INCREMENT PRIMARY KEY,
    id_material INT NOT NULL,
    id_user INT NOT NULL,
    quantity INT NOT NULL CHECK (quantity >= 0),
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_material) REFERENCES raw_material(id_material),
    FOREIGN KEY (id_user) REFERENCES user_account(id_user),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 1500000;

CREATE TABLE inventory_history (
    id_inventory_history INT AUTO_INCREMENT PRIMARY KEY,
    id_inventory INT NOT NULL,
    id_material INT NOT NULL,
    id_inventory_movement_type INT NOT NULL,
    quantity INT NOT NULL CHECK (quantity >= 0),
    movement_datetime TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_inventory) REFERENCES inventory(id_inventory),
    FOREIGN KEY (id_material) REFERENCES raw_material(id_material),
    FOREIGN KEY (id_state) REFERENCES state(id_state),
    FOREIGN KEY (id_inventory_movement_type) REFERENCES inventory_movement_type(id_inventory_movement_type)
) AUTO_INCREMENT = 1600000;

CREATE TABLE product (
    id_product INT AUTO_INCREMENT PRIMARY KEY,
    id_product_type INT NOT NULL,
    name VARCHAR(30) NOT NULL CHECK (LENGTH(name) >= 3),
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    description VARCHAR(200) CHECK (LENGTH(description) >= 3),
    image_url VARCHAR(254) NOT NULL,
    rating DECIMAL(3,1) CHECK (rating BETWEEN 1 AND 5),
    warning VARCHAR(254) NOT NULL,
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_product_type) REFERENCES product_type(id_product_type),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 1200000;

//seriamente hay que discutir si de verdad es necesario que id_user este aquí, tuve que poner eso, para que todo fuera bien.
CREATE TABLE production (
    id_production INT AUTO_INCREMENT PRIMARY KEY,
    start_datetime TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    end_datetime DATETIME NULL,
    total_products INT NOT NULL CHECK (total_products >= 0),
    id_production_status INT NOT NULL,
    id_user INT NOT NULL DEFAULT 700002 CHECK (id_user = 700002), -- Solo permite al admin
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_production_status) REFERENCES production_status(id_production_status),
    FOREIGN KEY (id_user) REFERENCES user_account(id_user),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 1800000;


CREATE TABLE production_detail (
    id_production INT NOT NULL,
    id_product INT NOT NULL,
    planned_quantity INT NOT NULL CHECK (planned_quantity >= 0),
    id_state INT NOT NULL DEFAULT 1,
    PRIMARY KEY (id_production, id_product),
    FOREIGN KEY (id_production) REFERENCES production(id_production),
    FOREIGN KEY (id_product) REFERENCES product(id_product),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
);

CREATE TABLE production_history (
    id_production_history INT AUTO_INCREMENT PRIMARY KEY,
    id_production INT NOT NULL,
    id_product INT NOT NULL,
    quantity INT NOT NULL CHECK (quantity >= 0),
    id_production_movement_type INT NOT NULL,
    movement_datetime TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_production, id_product) REFERENCES production_detail(id_production, id_product),
    FOREIGN KEY (id_state) REFERENCES state(id_state),
    FOREIGN KEY (id_production_movement_type) REFERENCES production_movement_type(id_production_movement_type)
) AUTO_INCREMENT = 1900000;

CREATE TABLE review (
    id_review INT AUTO_INCREMENT PRIMARY KEY,
    id_user INT NOT NULL,
    id_product INT NOT NULL,
    comment VARCHAR(250) NOT NULL,
    rating INT NOT NULL CHECK (rating BETWEEN 1 AND 5),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_user) REFERENCES user_account(id_user),
    FOREIGN KEY (id_product) REFERENCES product(id_product),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 2200000;


CREATE TABLE recipe (
    id_product INT NOT NULL,
    id_material INT NOT NULL,
    quantity_required INT NOT NULL CHECK (quantity_required >= 0),
    id_state INT NOT NULL DEFAULT 1,
    PRIMARY KEY (id_product, id_material),
    FOREIGN KEY (id_product) REFERENCES product(id_product),
    FOREIGN KEY (id_material) REFERENCES raw_material(id_material),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
);


CREATE TABLE catalog (
    id_catalog INT AUTO_INCREMENT PRIMARY KEY,
    id_product INT NOT NULL,
    discount DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    id_state INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_product) REFERENCES product(id_product),
    FOREIGN KEY (id_state) REFERENCES state(id_state)
) AUTO_INCREMENT = 2000000;


/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////---INSERCIONES---///////////////////////////////

INSERT INTO state (name) VALUES 
('active'), 
('inactive'), 
('deleted');


INSERT INTO role (name) VALUES 
('Cliente'), 
('Administrador');


INSERT INTO product_type (name) VALUES 
('Tradicional'), 
('Natural'), 
('Orgánico'), 
('Vegano'), 
('Sin Gluten');


INSERT INTO order_status (name, description) VALUES 
('Recepción', 'Pedido pendiente de procesamiento'),
('Preparando', 'Pedido en preparación'),
('Empaquetado', 'Pedido empaquetado y listo para envío'),
('Envio', 'Pedido en camino al cliente'),
('Entregado', 'Pedido entregado al cliente');


INSERT INTO material_type (name) VALUES 
('Harinas'),
('Azúcares y Edulcorantes'),
('Grasas y Aceites'),
('Levaduras y Fermentos'),
('Lácteos'),
('Conservantes'),
('Frutas y Frutos Secos'),
('Aromas y Sabores'),
('Huevos y Ovoproductos'),
('Sal'),
('Aditivos y Mejoradores'),
('Coberturas y Decoraciones');


INSERT INTO unit (name) VALUES 
('Kilogramos'),
('Gramos'),
('Litros'),
('Mililitros'),
('Unidades');


INSERT INTO production_status (name) VALUES 
('En Producción'),
('Finalizado');


INSERT INTO production_movement_type (name, description) VALUES 
('Ingreso', 'Movimiento de ingreso en producción'),
('Salida', 'Movimiento de salida de producción'),
('Cancelado', 'Movimiento de cancelación de producción'),
('Item Eliminado', 'Movimiento de eliminación de un ítem en producción');


INSERT INTO user_account (email, password) VALUES 
('juan.perez@gmail.com', 'contrasena123'),
('alfredo@gmail.com', 'pass12345'),
('espriellag8@gmail.com', 'adminpass456'),
('maria.lopez@gmail.com', 'mariapass789'),
('pedro.martinez@gmail.com', 'pedropass101');


INSERT INTO user_role (id_user, id_role) VALUES 
(700000, 100000),  -- juan.perez@gmail.com
(700001, 100000),  -- alfredo@gmail.com
(700002, 100001),  -- espriellag8@gmail.com (administrador)
(700003, 100000),  -- maria.lopez@gmail.com
(700004, 100000);  -- pedro.martinez@gmail.com


INSERT INTO user_profile (id_user, first_name, last_name, address, phone) VALUES 
(700000, 'Juan', 'Pérez', 'Calle 123', '5551234'),
(700001, 'Alfredo', 'Gómez', 'Calle sin nombre', '5554567'),
(700002, 'Guillermo', 'Medina', 'Avenida 456', '5555678'),
(700003, 'María', 'López', 'Calle Las Rosas 789', '5556789'),
(700004, 'Pedro', 'Martínez', 'Calle Los Almendros 456', '5557890');


INSERT INTO inventory_movement_type (name, description, id_state) VALUES
('Creación', 'Movimiento de creación de inventario', 1),
('Ingreso', 'Movimiento de ingreso de material al inventario', 1),
('Salida', 'Movimiento de salida de material del inventario', 1),
('Eliminación', 'Movimiento de eliminación de registro de inventario', 1);


INSERT INTO product (id_product_type, name, price, description, image_url, rating, warning) VALUES 
(200000, 'Panetón', 15000.00, 'Pan dulce con frutas confitadas y pasas', 'url_imagen_panetón.jpg', NULL, 'Conservar en un lugar fresco.'),
(200000, 'Pan Integral', 12000.00, 'Pan denso con salvado y fibra', 'url_imagen_integral.jpg', NULL, 'Consumir antes de la fecha de caducidad.'),
(200001, 'Baguette', 10000.00, 'Pan largo y crujiente, con miga ligera', 'url_imagen_baguette.jpg', NULL, 'Mejor si se consume el día de compra.'),
(200002, 'Pan Blanco', 5000.00, 'Pan suave y esponjoso, ideal para todo', 'url_imagen_blanco.jpg', NULL, 'Almacenar en un lugar seco.'),
(200003, 'Focaccia', 18000.00, 'Pan italiano con aceite de oliva y hierbas', 'url_imagen_focaccia.jpg', NULL, 'Conservar en un lugar fresco.'),
(200004, 'Ciabatta', 14000.00, 'Pan italiano con una corteza crujiente y miga aireada', 'url_imagen_ciabatta.jpg', NULL, 'Consumir dentro de los 3 días.'),
(200001, 'Pan de Ajo', 11000.00, 'Pan suave con un delicioso sabor a ajo', 'url_imagen_pan_ajo.jpg', NULL, 'Calentar antes de servir.');


INSERT INTO raw_material (id_material_type, name, description, id_unit) VALUES 
(400000, 'Haz de oros', 'Harina blanca común para panadería', 500000),
(400000, 'Corona', 'Harina de trigo integral para panes más saludables', 500000),
(400001, 'La soberana', 'Azúcar refinada utilizada para endulzar', 500001),
(400001, 'Miel', 'Miel de abeja natural para endulzar y dar sabor', 500001),
(400002, 'Gustocita', 'Mantequilla sin sal para masas y cremas', 500001),
(400002, 'Aceite Lite', 'Aceite de girasol para mezclar en recetas líquidas', 500002),
(400003, 'Levadude', 'Levadura para fermentación de masas de pan', 500001),
(400003, 'Brisa Fresca', 'Levadura fresca para panes artesanales', 500001),
(400004, 'Alqueria', 'Leche líquida para mezclar en recetas de panadería', 500002),
(400004, 'Maxima cream', 'Nata líquida para preparar cremas y rellenos', 500002),
(400005, 'Sorbato de Potasio', 'Conservante utilizado para prolongar la vida útil de productos horneados', 500001),
(400006, 'Pasas', 'Frutas deshidratadas para agregar a masas y decoraciones', 500001),
(400006, 'Nueces', 'Frutos secos para mezclar en masas y como decoración', 500001),
(400009, 'Refial', 'Sal de mesa para dar sabor y mejorar la textura de las masas', 500001),
(400008, 'AA', 'Huevos frescos para mezclar en la masa y dar estructura', 500004),
(400011, 'Roma dulce', 'Chocolate oscuro para decorar y recubrir productos', 500001);


INSERT INTO inventory (id_material, id_user, quantity, id_state) VALUES 
(1400000, 700002, 50, 1), -- Haz de oros
(1400001, 700002, 25, 1), -- Corona
(1400002, 700002, 10000, 1), -- La soberana
(1400003, 700002, 2000, 1), -- Miel
(1400004, 700002, 5000, 1), -- Gustocita
(1400005, 700002, 10, 1), -- Aceite Lite
(1400006, 700002, 200, 1), -- Levadude
(1400007, 700002, 500, 1), -- Brisa Fresca
(1400008, 700002, 50, 1), -- Alqueria
(1400009, 700002, 20, 1), -- Maxima cream
(1400010, 700002, 500, 1), -- Sorbato de Potasio
(1400011, 700002, 2000, 1), -- Pasas
(1400012, 700002, 1500, 1), -- Nueces
(1400013, 700002, 5000, 1), -- Refial
(1400014, 700002, 600, 1), -- AA
(1400015, 700002, 4000, 1); -- Roma dulce


-- Comentarios sobre Pan de Ajo (ID_PRODUCT = 1200006)
INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700000, 1200006, 'Sabor a ajo delicioso, pero me gustaría que fuera un poco más crujiente.', 4);

INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700001, 1200006, 'El pan de ajo es un favorito en casa. Siempre lo pido para acompañar la pasta.', 5);

-- Comentarios sobre Ciabatta (ID_PRODUCT = 1200005)
INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700003, 1200005, 'Me decepcionó un poco, esperaba algo más crujiente. Estaba un poco seco.', 3);

INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700004, 1200005, 'La ciabatta es perfecta para hacer sándwiches. ¡Me encanta su textura!', 5);

-- Comentarios sobre Focaccia (ID_PRODUCT = 1200004)
INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700001, 1200004, 'Buen pan, pero un poco salado para mi gusto. Sin embargo, sigue siendo delicioso.', 4);

INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700003, 1200004, 'La focaccia es increíble. El aceite de oliva le da un sabor espectacular.', 5);

-- Comentarios sobre Pan Blanco (ID_PRODUCT = 1200003)
INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700004, 1200003, 'Demasiado esponjoso para mi gusto. Preferiría algo más denso.', 2);

INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700000, 1200003, 'Este pan blanco es muy suave y perfecto para hacer tostadas. ¡Me encanta!', 5);

-- Comentarios sobre Baguette (ID_PRODUCT = 1200002)
INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700001, 1200002, 'Buen sabor, pero se puso duro rápido. Mejor consumir el mismo día.', 3);

INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700004, 1200002, 'Excelente baguette, crujiente y fresco. Perfecto para mis sándwiches.', 5);

-- Comentarios sobre Pan Integral (ID_PRODUCT = 1200001)
INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700003, 1200001, 'Me gustó, pero la textura es un poco densa. Aún así, lo volveré a comprar.', 4);

INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700000, 1200001, 'El pan integral tiene un sabor excepcional, ideal para mis desayunos saludables.', 5);

-- Comentarios sobre Panetón (ID_PRODUCT = 1200000)
INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700001, 1200000, 'Muy rico, pero un poco más seco de lo que esperaba. Ideal para acompañar con café.', 3);

INSERT INTO review (id_user, id_product, comment, rating)
VALUES (700004, 1200000, 'El panetón es realmente delicioso, pero me hubiera gustado que tuviera más frutas. ¡Aún así, muy bueno!', 4);


-- Producto con descuento del 10% - Panetón
INSERT INTO catalog (id_product, discount) VALUES (1200000, 10);

-- Producto sin descuento - Pan Integral
INSERT INTO catalog (id_product, discount) VALUES (1200001, 0);

-- Producto con descuento del 15% - Baguette
INSERT INTO catalog (id_product, discount) VALUES (1200002, 15);

-- Producto sin descuento - Pan Blanco
INSERT INTO catalog (id_product, discount) VALUES (1200003, 0);

-- Producto con descuento del 5% - Focaccia
INSERT INTO catalog (id_product, discount) VALUES (1200004, 5);

-- Producto con descuento del 8% - Ciabatta
INSERT INTO catalog (id_product, discount) VALUES (1200005, 8);

-- Producto sin descuento - Pan de Ajo
INSERT INTO catalog (id_product, discount) VALUES (1200006, 0);


-- Pedido 1: Juan Pérez (Recepción)
INSERT INTO order_header (id_user, id_order_status, total_discount, total_amount)
VALUES (700000, 300000, 0, 0);

-- Pedido 2: Alfredo (Empaquetado)
INSERT INTO order_header (id_user, id_order_status, total_discount, total_amount)
VALUES (700001, 300002, 0, 0);

-- Pedido 3: María López (Envío)
INSERT INTO order_header (id_user, id_order_status, total_discount, total_amount)
VALUES (700003, 300003, 0, 0);

-- Pedido 4: Pedro Martínez (Preparando)
INSERT INTO order_header (id_user, id_order_status, total_discount, total_amount)
VALUES (700004, 300001, 0, 0);

-- Pedido 5: Pedro Martínez (Entregado)
INSERT INTO order_header (id_user, id_order_status, total_discount, total_amount)
VALUES (700004, 300004, 0, 0);


-- Panetón
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200000, 1400000, 10, 1); -- Harina de Trigo
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200000, 1400002, 2, 1);  -- Azúcar Blanca
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200000, 1400011, 0.5, 1); -- Pasas
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200000, 1400007, 0.05, 1); -- Levadura Fresca
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200000, 1400004, 1, 1);  -- Mantequilla

-- Pan Integral
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200001, 1400001, 8, 1);   -- Harina Integral
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200001, 1400002, 1, 1);   -- Azúcar Blanca
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200001, 1400007, 0.05, 1);-- Levadura Fresca
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200001, 1400013, 0.1, 1); -- Sal
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200001, 1400005, 0.5, 1); -- Aceite Vegetal

-- Focaccia
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200002, 1400000, 6, 1);   -- Harina de Trigo
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200002, 1400006, 0.02, 1);-- Levadura Seca
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200002, 1400013, 0.1, 1); -- Sal
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200002, 1400008, 1, 1);   -- Agua

-- Pan Francés
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200003, 1400000, 5, 1);   -- Harina de Trigo
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200003, 1400002, 0.5, 1); -- Azúcar Blanca
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200003, 1400007, 0.05, 1);-- Levadura Fresca
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200003, 1400008, 2, 1);   -- Agua

-- Pan Ciabatta
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200004, 1400000, 6, 1);   -- Harina de Trigo
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200004, 1400013, 0.1, 1); -- Sal
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200004, 1400005, 0.2, 1); -- Aceite Vegetal
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200004, 1400006, 0.03, 1);-- Levadura Seca

-- Pan de Mesa
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200005, 1400000, 5, 1);   -- Harina de Trigo
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200005, 1400006, 0.03, 1);-- Levadura Seca
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200005, 1400013, 0.05, 1);-- Sal
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200005, 1400008, 1.5, 1); -- Agua

-- Pan Dulce
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200006, 1400000, 3, 1);   -- Harina de Trigo
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200006, 1400013, 0.05, 1);-- Sal
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200006, 1400005, 0.1, 1); -- Aceite Vegetal
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200006, 1400003, 0.1, 1); -- Miel
INSERT INTO recipe (id_product, id_material, quantity_required, id_state) VALUES (1200006, 1400006, 0.02, 1);-- Levadura Seca


-- Inserciones para producción (solo admin - 700002)
INSERT INTO production (total_products, id_production_status)
VALUES 
(90, 600000),  -- Producción en curso
(150, 600001); -- Producción finalizada

-- Detalles para producción 1800000 (en curso)
INSERT INTO production_detail (id_production, id_product, planned_quantity)
VALUES
(1800000, 1200000, 30), -- Panetón
(1800000, 1200001, 30), -- Pan Integral
(1800000, 1200002, 30); -- Baguette

-- Detalles para producción 1800001 (finalizada)
INSERT INTO production_detail (id_production, id_product, planned_quantity)
VALUES
(1800001, 1200003, 50), -- Pan Blanco
(1800001, 1200004, 50), -- Focaccia
(1800001, 1200005, 50); -- Ciabatta


INSERT INTO production_movement_type (name, description)
VALUES
('Entrada', 'Registro de nueva producción con sus detalles'),
('Salida', 'Finalización de una producción'),
('Reactivación', 'Reapertura de una producción finalizada'),
('Cancelación', 'Cancelación de una producción y sus detalles');



/////////////////////////////////////////////////////////////////////////////////
////////////////////////////////---RESTRICCIONES---//////////////////////////////

//mientras se soluciona el de si el campo deberia ir o no en inventory
ALTER TABLE inventory MODIFY id_user INT NOT NULL CHECK(id_user = 700002);

ALTER TABLE review 
ADD CONSTRAINT chk_no_admin_reviews 
CHECK (id_user <> 700002);


ALTER TABLE order_header
ADD CONSTRAINT chk_no_admin_orders
CHECK (id_user <> 700002);


//Guillermo no paso la query de esto:
ALTER TABLE user_account
ADD COLUMN reset_token VARCHAR(512) NULL COMMENT 'Reset password token',
ADD COLUMN reset_token_expires DATETIME NULL COMMENT 'Reset password expiration datetime';

ALTER TABLE user_account
ADD COLUMN verify_token VARCHAR(512) NULL COMMENT 'Email verification token';

ALTER TABLE user_account
ADD COLUMN verified TINYINT(1) NOT NULL DEFAULT 0 COMMENT 'Indicate if the account is verified';

ALTER TABLE catalog ADD CONSTRAINT uq_catalog_id_product UNIQUE (id_product);

ALTER TABLE user_account ADD COLUMN is_logged_in BOOLEAN DEFAULT FALSE;


/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////---OBJETOS DE LA BASE---////////////////////////////


--------------------------------------VIEWS--------------------------------------

CREATE VIEW vw_cart_by_user AS
SELECT * FROM cart;

///Inventario

CREATE OR REPLACE VIEW vw_active_inventory AS
SELECT 
  inv.id_inventory,
  inv.quantity,
  mat.name AS raw_material,
  uni.name AS unit,
  uni.id_unit,
  typ.name AS type,
  typ.id_type_material,
  mat.description
FROM inventory inv
JOIN raw_material mat ON inv.id_material = mat.id_material
JOIN unit uni ON mat.id_unit = uni.id_unit
JOIN material_type typ ON mat.id_material_type = typ.id_type_material
WHERE inv.id_state = 1
  AND mat.id_state = 1
  AND uni.id_state = 1
  AND typ.id_state = 1;

CREATE OR REPLACE VIEW VW_ACTIVE_MATERIAL_TYPES AS
SELECT 
    ID_TIP_MATERIA   AS ID_TIP_MATERIA,
    NOMBRE           AS NOMBRE
FROM 
    MATERIAL_TYPE
WHERE 
    ID_STATE = 1;


CREATE VIEW vw_active_units AS
SELECT id_unit AS ID_UNIDAD, name AS NOMBRE 
FROM unit 
WHERE id_state = 1;


CREATE OR REPLACE VIEW vw_active_inventory_history AS
SELECT 
    h.id_inventory_history AS ID_HYS_INVENTARIO, 
    h.id_inventory AS ID_INVENTARIO, 
    h.id_material AS ID_MATERIA, 
    m.name AS NOMBRE_MATERIA,
    h.quantity AS CANTIDAD, 
    hm.name AS TIPO_MOVIMIENTO, 
    h.movement_datetime AS FECHA_MOVIMIENTO
FROM 
    inventory_history h
JOIN 
    raw_material m ON h.id_material = m.id_material
JOIN 
    inventory_movement_type hm ON hm.id_inventory_movement_type = h.id_inventory_movement_type
WHERE 
    m.id_state = 1
ORDER BY 
    h.movement_datetime DESC;


CREATE OR REPLACE VIEW vw_active_inventory_summary AS
SELECT 
    i.id_material AS ID_MATERIA, 
    m.name AS NOMBRE_MATERIA, 
    SUM(i.quantity) AS CANTIDAD_TOTAL, 
    u.name AS UNIDAD
FROM 
    inventory i
JOIN 
    raw_material m ON i.id_material = m.id_material
JOIN 
    unit u ON m.id_unit = u.id_unit
WHERE 
    i.id_state = 1
    AND m.id_state = 1
    AND u.id_state = 1
GROUP BY 
    i.id_material, m.name, u.name;


CREATE VIEW vw_active_orders AS
SELECT 
    p.id_order AS ID_PEDIDO, 
    p.created_at AS FECHA_HORA, 
    p.total_amount AS TOTAL_PAGAR, 
    e.name AS ESTADO
FROM 
    order_header p
JOIN 
    order_status e ON p.id_order_status = e.id_order_status
WHERE 
    p.id_state = 1;


CREATE VIEW vw_active_orders_admin AS
SELECT 
    oh.id_order,
    oh.id_user,
    oh.id_order_status,
    oh.created_at,
    oh.total_discount,
    oh.total_amount,
    os.name AS order_status_name
FROM 
    order_header oh
JOIN 
    order_status os ON oh.id_order_status = os.id_order_status
WHERE 
    oh.id_state = 1 AND
    os.id_state = 1;


CREATE or REPLACE VIEW vw_get_all_orders_and_details_by_user AS
SELECT 
    oh.id_order,
    oh.id_user,
    oh.id_order_status,
    oh.created_at,
    oh.total_discount,
    oh.total_amount,
    od.id_order_detail,
    od.id_product,
    od.quantity,
    od.final_price,
    p.name AS product_name,
    p.price AS product_price
FROM 
    order_header oh
JOIN 
    order_detail od ON oh.id_order = od.id_order
JOIN 
    product p ON od.id_product = p.id_product
WHERE 
    oh.id_state = 1 AND
    od.id_state = 1 AND
    p.id_state = 1;


CREATE VIEW vw_get_order_details_by_order_id AS
SELECT 
    oh.id_order,
    oh.id_user,
    oh.id_order_status,
    oh.created_at,
    oh.total_discount,
    oh.total_amount,
    od.id_order_detail,
    od.id_product,
    od.quantity,
    od.final_price,
    p.name AS product_name,
    p.price AS product_price
FROM 
    order_header oh
JOIN 
    order_detail od ON oh.id_order = od.id_order
JOIN 
    product p ON od.id_product = p.id_product
WHERE 
    oh.id_state = 1 AND
    od.id_state = 1 AND
    p.id_state = 1;


CREATE VIEW vw_order_status AS
SELECT 
    os.id_order_status,
    os.name AS status_name,
    os.description,
    os.id_state
FROM 
    order_status os
WHERE 
    os.id_state = 1;  -- Solo se incluyen estados activos


CREATE VIEW vw_active_order_details AS
SELECT 
    p.id_order AS ID_PEDIDO, 
    p.created_at AS FECHA_HORA, 
    p.total_discount AS TOTAL_DESCUENTO, 
    p.total_amount AS TOTAL_PAGAR, 
    e.name AS ESTADO, 
    u.id_user AS ID_CLIENTE, 
    up.first_name AS NOMBRES, 
    up.last_name AS APELLIDOS, 
    up.address AS DIRECCION, 
    up.phone AS TELEFONO
FROM 
    order_header AS p
JOIN 
    order_status AS e ON p.id_order_status = e.id_order_status
JOIN 
    user_account AS u ON p.id_user = u.id_user
JOIN 
    user_profile AS up ON u.id_user = up.id_user
WHERE 
    p.id_state = 1 
    AND u.id_user <> 700002;


CREATE VIEW vw_active_order_items AS
SELECT 
    od.id_order_detail AS ID_DETALLE_PEDIDO, 
    od.id_order AS ID_PEDIDO, 
    od.id_product AS ID_PRODUCTO, 
    od.quantity AS CANTIDAD, 
    od.final_price AS PRECIO_FINAL, 
    p.name AS PRODUCTO_NOMBRE, 
    p.description AS DESCRIPCION, 
    p.image_url AS IMAGEN_URL
FROM 
    order_detail od
JOIN 
    product p ON od.id_product = p.id_product
WHERE 
    od.id_state = 1; 


CREATE OR REPLACE VIEW vw_active_find_user_by_id AS
SELECT 
    id_user, 
    email, 
    password, 
    id_state
FROM 
    user_account
WHERE 
    id_state = 1;


CREATE OR REPLACE VIEW vw_active_find_user_by_email AS
SELECT 
    id_user, 
    email, 
    password, 
    id_state
FROM 
    user_account
WHERE 
    id_state = 1;


CREATE OR REPLACE VIEW vw_active_get_user_info AS
SELECT 
    u.id_user,
    u.email,
    u.password,
    r.id_role,
    r.name AS role_name,
    d.first_name,
    d.last_name,
    d.address,
    d.phone
FROM 
    user_account u
JOIN 
    user_role ur ON u.id_user = ur.id_user
JOIN 
    role r ON ur.id_role = r.id_role
JOIN 
    user_profile d ON u.id_user = d.id_user
WHERE 
    u.id_state = 1 
    AND ur.id_state = 1
    AND r.id_state = 1
    AND d.id_state = 1;


DROP VIEW IF EXISTS vw_get_users_info;
CREATE VIEW vw_get_users_info AS
SELECT 
    u.id_user,
    u.email,
    u.password,
    u.id_state as ID_STATE,  -- Mapear id_state a ID_STATE
    r.name as role_name,
    r.id_role,
    d.first_name,
    d.last_name,
    d.address,
    d.phone
FROM user_account u
JOIN user_role ur ON u.id_user = ur.id_user
JOIN role r ON ur.id_role = r.id_role AND r.id_role = 100000
JOIN user_profile d ON u.id_user = d.id_user
WHERE (u.id_state = 1 OR u.id_state = 2)
  AND ur.id_state = 1
  AND r.id_state = 1
  AND d.id_state = 1;

CREATE OR REPLACE VIEW vw_active_get_client_id AS
SELECT 
    id_user AS ID_CLIENTE
FROM 
    user_account
WHERE 
    id_state = 1;


CREATE OR REPLACE VIEW vw_active_products AS
SELECT 
    p.id_product AS id,
    p.name AS nameProduct,
    p.description AS description,
    p.price AS price,
    p.image_url AS image,
    p.rating AS rating,
    tp.name AS category,
    c.discount AS discount
FROM product p
JOIN product_type tp ON p.id_product_type = tp.id_product_type
JOIN catalog c ON p.id_product = c.id_product
WHERE p.id_state = 1
  AND tp.id_state = 1
  AND c.id_state = 1;


CREATE OR REPLACE VIEW vw_active_categories AS
SELECT 
    name AS NOMBRE
FROM product_type
WHERE id_state = 1;


CREATE OR REPLACE VIEW vw_active_recipe AS
SELECT 
    r.id_product AS ID_RECETA,
    p.name AS NOMBRE_PROD,
    m.name AS NOMBRE_MATE,
    m.id_material AS ID_MATERIA,
    r.quantity_required AS CANTIDAD_USAR
FROM recipe r
JOIN product p ON p.id_product = r.id_product
JOIN raw_material m ON m.id_material = r.id_material
WHERE 
    r.id_state = 1
    AND p.id_state = 1
    AND m.id_state = 1;



//VISTA 2 - FUNCIONAL
CREATE OR REPLACE VIEW vw_active_product_admin AS
SELECT
  p.id_product AS ID_PRODUCTO,
  p.id_product_type AS ID_TIPO_PRO,
  t.name AS NOMBRE_TIPO_PRO,
  p.name AS NOMBRE_PROD,
  p.price AS PRECIO,
  p.description AS DESCRIPCION,
  p.image_url AS IMAGEN_URL,
  p.rating AS NOTA_ACTUAL,
  p.warning AS ADVERTENCIA,
  p.id_state AS ID_STATE
FROM product p
JOIN product_type t ON p.id_product_type = t.id_product_type
WHERE (p.id_state = 1 OR p.id_state = 2)
  AND (t.id_state = 1 OR t.id_state = 2);


-- Vista para producciones activas
CREATE OR REPLACE VIEW vw_get_active_production AS
SELECT 
    p.id_production,
    p.start_datetime,
    p.end_datetime,
    p.total_products,
    ps.name AS production_status,
    p.id_user
FROM production p
JOIN production_status ps ON p.id_production_status = ps.id_production_status
WHERE 
    p.id_state = 1 AND
    ps.id_state = 1;

-- Vista para detalles activos de producción
CREATE OR REPLACE VIEW vw_get_active_production_detail AS
SELECT 
    pd.id_production,
    pd.id_product,
    pr.name AS product_name,
    pd.planned_quantity
FROM production_detail pd
JOIN product pr ON pr.id_product = pd.id_product
WHERE 
    pd.id_state = 1 AND
    pr.id_state = 1;


CREATE OR REPLACE VIEW vw_get_production_status AS
SELECT 
    id_production_status,
    name
FROM 
    production_status
WHERE 
    id_state = 1;


CREATE OR REPLACE VIEW vw_production_report AS
SELECT 
    p.id_production        AS id_produccion,
    p.start_datetime       AS fecha_inicio,
    p.end_datetime         AS fecha_fin,
    p.total_products       AS total_productos,
    pd.id_product          AS id_producto,
    pr.name                AS nombre_producto,
    pd.planned_quantity    AS cantidad_planeada
FROM production p
INNER JOIN production_detail pd 
    ON p.id_production = pd.id_production
INNER JOIN product pr 
    ON pd.id_product = pr.id_product
WHERE p.id_state = 1
  AND pd.id_state = 1
  AND pr.id_state = 1;


CREATE OR REPLACE VIEW vw_production_history AS
SELECT 
    h.id_production_history AS id_historial,
    h.id_production        AS id_produccion,
    p.start_datetime       AS fecha_inicio,
    p.end_datetime         AS fecha_fin,
    p.total_products       AS total_productos,
    h.id_product           AS id_producto,
    pr.name                AS nombre_producto,
    h.quantity             AS cantidad,
    mt.name                AS tipo_movimiento,
    mt.description         AS descripcion_movimiento,
    h.movement_datetime    AS fecha_movimiento
FROM production_history h
INNER JOIN production p 
    ON h.id_production = p.id_production
INNER JOIN product pr 
    ON h.id_product = pr.id_product
INNER JOIN production_movement_type mt 
    ON h.id_production_movement_type = mt.id_production_movement_type
WHERE mt.id_state = 1
  AND pr.id_state = 1
ORDER BY h.movement_datetime DESC;


-------------------------------------PROCEDURES----------------------------------

DELIMITER $$

CREATE PROCEDURE sp_get_cart_by_user(IN userId INT)
BEGIN
    SELECT * FROM vw_cart_by_user WHERE id_user = userId;
END $$

DELIMITER ;


//REEMPLAZA LA LOGICA EN CARTMODEL.js

DELIMITER $$
CREATE PROCEDURE sp_save_cart(IN userId INT, IN items JSON)
BEGIN
    DECLARE existingCount INT;

    SELECT COUNT(*) INTO existingCount FROM cart WHERE id_user = userId;

    IF existingCount > 0 THEN
        UPDATE cart SET items = items WHERE id_user = userId;
    ELSE
        INSERT INTO cart (id_user, items) VALUES (userId, items);
    END IF;
END $$


DELIMITER $$

CREATE PROCEDURE sp_clear_cart(IN userId INT)
BEGIN
    UPDATE cart 
    SET id_state = 3  -- Asumiendo que 3 es el estado de "eliminado"
    WHERE id_user = userId;
END $$

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_get_inventory()
BEGIN
    SELECT * FROM vw_active_inventory;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_update_quantity(
    IN p_id_inventory INT,
    IN p_quantity INT
)
BEGIN
    UPDATE inventory 
    SET quantity = p_quantity 
    WHERE id_inventory = p_id_inventory;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Registro no encontrado';
    END IF;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_update_raw_material(
    IN p_id_inventory INT,
    IN p_name VARCHAR(50),
    IN p_id_material_type INT,
    IN p_id_unit INT,
    IN p_description VARCHAR(254)
)
BEGIN
    DECLARE v_id_material INT;

    -- Obtener ID_MATERIA desde el inventario
    SELECT id_material INTO v_id_material 
    FROM inventory 
    WHERE id_inventory = p_id_inventory;

    IF v_id_material IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Inventario no encontrado';
    END IF;

    -- Actualizar materia_prima
    UPDATE raw_material 
    SET name = p_name, 
        id_material_type = p_id_material_type, 
        id_unit = p_id_unit, 
        description = p_description 
    WHERE id_material = v_id_material;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Materia prima no actualizada';
    END IF;
END //

DELIMITER ;


DELIMITER $$

CREATE or REPLACE PROCEDURE sp_delete_inventory(IN p_id_inventory INT)
BEGIN
    DECLARE v_quantity INT;

    -- Obtener la cantidad actual antes de actualizar
    SELECT quantity INTO v_quantity FROM inventory WHERE id_inventory = p_id_inventory;

    -- Actualizar el estado a eliminado
    UPDATE inventory 
    SET id_state = 3  -- Asumiendo que 3 es el estado de "eliminado"
    WHERE id_inventory = p_id_inventory;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Inventario no encontrado';
    ELSE
        -- Registrar el movimiento en inventory_history
        INSERT INTO inventory_history (
            id_inventory,
            id_material,
            id_inventory_movement_type,
            quantity,
            id_state
        ) VALUES (
            p_id_inventory,
            (SELECT id_material FROM inventory WHERE id_inventory = p_id_inventory),
            8, -- ID de 'Eliminación'
            v_quantity,
            3 -- Estado de eliminado
        );
    END IF;
END $$

DELIMITER ;


///no se esta usando este
DELIMITER //

CREATE PROCEDURE sp_get_material_types()
BEGIN
    SELECT * FROM vw_active_material_types;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_get_units()
BEGIN
    SELECT * FROM vw_active_units;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_add_new_raw_material(
    IN p_nombre VARCHAR(50),
    IN p_tipo_materia INT,
    IN p_unidad INT,
    IN p_cantidad INT,
    IN p_descripcion VARCHAR(254),
    IN p_id_administrador INT
)
BEGIN
    DECLARE v_id_material INT;

    -- Iniciar transacción
    START TRANSACTION;

    -- 1. Insertar en raw_material
    INSERT INTO raw_material (name, id_material_type, id_unit, description)
    VALUES (p_nombre, p_tipo_materia, p_unidad, p_descripcion);

    SET v_id_material = LAST_INSERT_ID();

    -- 2. Insertar en inventory
    INSERT INTO inventory (id_material, id_user, quantity)
    VALUES (v_id_material, p_id_administrador, p_cantidad);

    -- Confirmar transacción
    COMMIT;
END //

DELIMITER ;



DELIMITER //

CREATE PROCEDURE sp_get_inventory_summary()
BEGIN
    SELECT * FROM vw_active_inventory_summary;
END //

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_calculate_average_rating(IN p_id_producto INT)
BEGIN
    DECLARE v_promedio DECIMAL(3,1);

    -- Calcular el promedio de las calificaciones activas
    SELECT AVG(rating)
    INTO v_promedio
    FROM review
    WHERE id_product = p_id_producto AND id_state = 1;

    -- Actualizar la nota del producto (si está activo)
    UPDATE product
    SET rating = v_promedio
    WHERE id_product = p_id_producto AND id_state = 1;
END $$

DELIMITER ;

///ACTUALMENTE MANEJA EL CALCULO DE LOS TOTALES PARA PEDIDO Y DETALLES(NOMBRES EN INGLES)
//tiene que ser llamado para funcionar: CALL sp_calculate_order_totals(1100000);
--PENDIENTE DE REVISION DE LOGICA

DELIMITER $$

CREATE PROCEDURE sp_calculate_order_totals(IN p_id_order INT)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_id_product INT;
    DECLARE v_quantity INT;
    DECLARE v_price DECIMAL(10,2);
    DECLARE v_discount DECIMAL(5,2);
    DECLARE v_final_price DECIMAL(10,2);
    DECLARE v_line_discount DECIMAL(10,2);

    DECLARE total_descuento DECIMAL(10,2) DEFAULT 0;
    DECLARE total_a_pagar DECIMAL(10,2) DEFAULT 0;

    DECLARE cur CURSOR FOR
        SELECT od.id_product, od.quantity
        FROM order_detail od
        WHERE od.id_order = p_id_order;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    OPEN cur;

    leer_productos: LOOP
        FETCH cur INTO v_id_product, v_quantity;
        IF done THEN
            LEAVE leer_productos;
        END IF;

        -- Obtener precio del producto
        SELECT price INTO v_price
        FROM product
        WHERE id_product = v_id_product;

        -- Obtener descuento desde el catálogo (si no hay, se asume 0)
        SELECT COALESCE(discount, 0) INTO v_discount
        FROM catalog
        WHERE id_product = v_id_product
        LIMIT 1;

        -- Calcular precio final con descuento
        SET v_final_price = v_price * (1 - v_discount / 100);

        -- Calcular el descuento total en esta línea
        SET v_line_discount = (v_price - v_final_price) * v_quantity;

        -- Actualizar order_detail con precio final
        UPDATE order_detail
        SET final_price = v_final_price
        WHERE id_order = p_id_order AND id_product = v_id_product;

        -- Sumar al total
        SET total_descuento = total_descuento + v_line_discount;
        SET total_a_pagar = total_a_pagar + (v_final_price * v_quantity);
    END LOOP;

    CLOSE cur;

    -- Actualizar totales en order_header
    UPDATE order_header
    SET total_discount = total_descuento,
        total_amount = total_a_pagar
    WHERE id_order = p_id_order;

END$$

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_insert_order_header(
    IN p_id_user INT,
    IN p_id_order_status INT,
    OUT p_order_id INT
)
BEGIN
    INSERT INTO order_header (id_user, id_order_status) VALUES (p_id_user, p_id_order_status);
    SET p_order_id = LAST_INSERT_ID();
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_insert_order_detail(
    IN p_id_order INT,
    IN p_id_product INT,
    IN p_quantity INT
)
BEGIN
    INSERT INTO order_detail (id_order, id_product, quantity) VALUES (p_id_order, p_id_product, p_quantity);
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_get_client_orders(
    IN p_client_id INT
)
BEGIN
    SELECT * 
    FROM vw_active_orders 
    WHERE ID_PEDIDO IN (
        SELECT id_order 
        FROM order_header 
        WHERE id_user = p_client_id
    );
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_get_order_details(
    IN p_order_id INT
)
BEGIN
    SELECT * 
    FROM vw_active_order_details 
    WHERE ID_PEDIDO = p_order_id;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE sp_get_order_items(
    IN p_order_id INT
)
BEGIN
    SELECT * 
    FROM vw_active_order_items 
    WHERE ID_PEDIDO = p_order_id;
END //

DELIMITER ;


DROP PROCEDURE IF EXISTS sp_insert_recipe;
DELIMITER $$

CREATE PROCEDURE sp_insert_recipe(
    IN p_id_product INT,
    IN p_id_material INT,
    IN p_quantity_required INT
)
BEGIN
    INSERT INTO recipe (id_product, id_material, quantity_required)
    VALUES (p_id_product, p_id_material, p_quantity_required);
END $$

DELIMITER ;


DROP PROCEDURE IF EXISTS sp_update_recipe;
DELIMITER $$

CREATE PROCEDURE sp_update_recipe(
    IN p_id_product INT,
    IN p_id_material INT,
    IN p_quantity_required INT
)
BEGIN
    UPDATE recipe
    SET quantity_required = p_quantity_required
    WHERE id_product = p_id_product AND id_material = p_id_material;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Recipe entry not found';
    END IF;
END $$

DELIMITER ;



DROP PROCEDURE IF EXISTS sp_delete_recipe;
DELIMITER $$

CREATE PROCEDURE sp_delete_recipe(
    IN p_id_product INT,
    IN p_id_material INT
)
BEGIN
    UPDATE recipe
    SET id_state = 3 -- assuming 3 means deleted
    WHERE id_product = p_id_product AND id_material = p_id_material;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Recipe entry not found';
    END IF;
END $$

DELIMITER ;


DROP PROCEDURE IF EXISTS sp_insert_product_admin;
DELIMITER $$
CREATE PROCEDURE sp_insert_product_admin(
  IN p_id_product_type INT,
  IN p_name VARCHAR(30),
  IN p_price DECIMAL(10, 2),
  IN p_description VARCHAR(200),
  IN p_image_url VARCHAR(254),
  IN p_rating DECIMAL(3,1),
  IN p_warning VARCHAR(254)
)
BEGIN
  INSERT INTO product (
    id_product_type, name, price, description, image_url, rating, warning
  ) VALUES (
    p_id_product_type, p_name, p_price, p_description, p_image_url, p_rating, p_warning
  );
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS sp_update_product_admin;
DELIMITER $$
CREATE PROCEDURE sp_update_product_admin(
  IN p_id_product INT,
  IN p_id_product_type INT,
  IN p_name VARCHAR(30),
  IN p_price DECIMAL(10, 2),
  IN p_description VARCHAR(200),
  IN p_image_url VARCHAR(254),
  IN p_rating DECIMAL(3,1),
  IN p_warning VARCHAR(254)
)
BEGIN
  UPDATE product
  SET
    id_product_type = p_id_product_type,
    name = p_name,
    price = p_price,
    description = p_description,
    image_url = p_image_url,
    rating = p_rating,
    warning = p_warning
  WHERE id_product = p_id_product AND id_state = 1;

  IF ROW_COUNT() = 0 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'product not found or inactive';
  END IF;
END $$
DELIMITER ;

//actualizado, culpa de brandon
DROP PROCEDURE IF EXISTS sp_delete_product_admin;
DELIMITER $$

CREATE PROCEDURE sp_delete_product_admin(IN p_id_product INT)
BEGIN
  DECLARE v_id_state INT;

  SELECT id_state INTO v_id_state
  FROM product
  WHERE id_product = p_id_product;

IF  v_id_state = 1 THEN
  UPDATE product
  SET id_state = 2
  WHERE id_product = p_id_product;

ELSEIF v_id_state = 2 THEN
 UPDATE product
  SET id_state = 1
  WHERE id_product = p_id_product;
  END IF;


  IF ROW_COUNT() = 0 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'product not found';
END IF;
END $$
DELIMITER ;


los que hizo guillermo------------------
------------------posiblemente haya que hacer cambios en algunos por el id_state


DELIMITER $$
CREATE PROCEDURE sp_create_user(
    IN p_email VARCHAR(100),
    IN p_pass VARCHAR(255),
    IN p_rolId INT,
    IN p_first_name VARCHAR(50),
    IN p_last_name VARCHAR(50),
    IN p_address VARCHAR(100),
    IN p_phone VARCHAR(15)
)
BEGIN
    DECLARE newUserId INT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- Si ocurre un error, revertimos todo
        ROLLBACK;
        SELECT 'Error al crear el usuario' AS message;
    END;

    START TRANSACTION;

    -- Insertamos el nuevo usuario
    INSERT INTO user_account (email, password)
    VALUES (p_email, p_pass);
    SET newUserId = LAST_INSERT_ID();

    --  Asignamos el rol
    INSERT INTO user_role (id_user, id_role)
    VALUES (newUserId, p_rolId);

    --  Insertamos el perfil del usuario
    INSERT INTO user_profile (id_user, first_name, last_name, address, phone)
    VALUES (newUserId, p_first_name, p_last_name, p_address, p_phone);

    COMMIT;

    -- Devolvemos el nuevo id
    SELECT newUserId AS userId;

END$$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_find_user_by_id(IN p_userId INT)
BEGIN
    SELECT * FROM vw_active_find_user_by_id WHERE id_user = p_userId LIMIT 1;
END$$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_get_user_info (IN p_userId INT)
BEGIN
    SELECT 
        id_user,
        email,
        password,
        id_role,
        role_name,
        first_name,
        last_name,
        address,
        phone
    FROM 
        vw_active_get_user_info
    WHERE 
        id_user = p_userId LIMIT 1;
END $$

DELIMITER ;


DROP PROCEDURE IF EXISTS sp_get_users_info;
DELIMITER $$
CREATE PROCEDURE sp_get_users_info()
BEGIN 
    SELECT 
        id_user,
        email,
        ID_STATE,
        first_name,
        last_name,
        address,
        phone,
        role_name
    FROM vw_get_users_info
    ORDER BY id_user;
END$$
DELIMITER ;



DELIMITER $$

CREATE PROCEDURE sp_get_client_id (IN p_userId INT)
BEGIN
    SELECT 
        ID_CLIENTE
    FROM 
        vw_active_get_client_id
    WHERE 
        ID_CLIENTE = p_userId LIMIT 1;
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_save_reset_token(
    IN p_userId INT,
    IN p_token VARCHAR(512)
)
BEGIN
    UPDATE user_account
    SET reset_token = p_token,
        reset_token_expires = DATE_ADD(NOW(), INTERVAL 1 HOUR)
    WHERE id_user = p_userId;
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_update_password_and_clear_token(
    IN p_userId INT,
    IN p_newPassword VARCHAR(255)
)
BEGIN
    UPDATE user_account
    SET password = p_newPassword,
        reset_token = NULL,
        reset_token_expires = NULL
    WHERE id_user = p_userId;
END $$

DELIMITER ;


//le cambie un poco el nombre a este
DELIMITER $$
DROP PROCEDURE IF EXISTS sp_update_password_and_clear_token $$

CREATE PROCEDURE sp_update_password_and_clean_token(
    IN p_userId INT,
    IN p_newPassword VARCHAR(255)
)
BEGIN
    UPDATE user_account
    SET password = p_newPassword,
        reset_token = NULL,
        reset_token_expires = NULL
    WHERE id_user = p_userId;
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_save_verify_token(
    IN p_userId INT,
    IN p_token VARCHAR(512)
)
BEGIN
    UPDATE user_account
    SET verify_token = p_token
    WHERE id_user = p_userId;
END $$

DELIMITER ;


//ya enserio, cuantos campos le puso
DELIMITER $$

DROP PROCEDURE IF EXISTS sp_verify_user_by_token $$

CREATE PROCEDURE sp_verify_user_by_token(IN p_token VARCHAR(512))
BEGIN
    DECLARE v_userId INT;

    SELECT id_user INTO v_userId FROM user_account WHERE verify_token = p_token LIMIT 1;

    IF v_userId IS NOT NULL THEN
        UPDATE user_account SET verified = 1, verify_token = NULL WHERE id_user = v_userId;
        SELECT TRUE AS verified;
    ELSE
        SELECT FALSE AS verified;
    END IF;

END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_get_all_products()
BEGIN
    SELECT * FROM vw_active_products;
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_get_product_by_id(IN p_id INT)
BEGIN
    SELECT * FROM vw_active_products WHERE id = p_id LIMIT 1;
END $$

DELIMITER ;


//este tenia dos versiones, me quede con la primera, si sale error, es culpa de Guillermo por no aclarar cual era la funcional
DELIMITER $$

CREATE or REPLACE PROCEDURE sp_filter_products(
    IN p_searchTerm VARCHAR(255),
    IN p_category VARCHAR(255)
)
BEGIN
    SELECT * FROM vw_active_products
    WHERE
        (p_searchTerm IS NULL OR p_searchTerm = '' 
            OR nameProduct LIKE CONCAT('%', p_searchTerm, '%') 
            OR description LIKE CONCAT('%', p_searchTerm, '%'))
        AND (p_category IS NULL OR p_category = '' OR p_category = 'Todos' OR category = p_category);
END $$

DELIMITER ;

DELIMITER $$

CREATE PROCEDURE sp_get_featured_products(IN p_limit INT)
BEGIN
    SELECT 
        id, 
        nameProduct, 
        description, 
        price, 
        image, 
        rating, 
        category, 
        discount
    FROM vw_active_products
    ORDER BY rating DESC
    LIMIT p_limit;
END$$
DELIMITER ;

DELIMITER $$
CREATE or REPLACE PROCEDURE sp_get_categories()
BEGIN
    SELECT * FROM vw_active_categories;
END$$
DELIMITER ;

//lo de recetas de brandon
//cambiado recientemente - ahora funciona

DROP PROCEDURE IF EXISTS sp_insert_product_carrito_admin;
DELIMITER $$

CREATE PROCEDURE sp_insert_product_carrito_admin(
    IN p_id_catalog INT,
    IN p_id_product INT,
    IN p_discount DECIMAL(5,2)
)
BEGIN
    -- Verifica que el producto exista en la tabla 'product'
    IF EXISTS (
        SELECT 1 FROM product WHERE id_product = p_id_product
    ) THEN
    
        -- Verifica si el producto ya está en el catálogo
        IF EXISTS (
            SELECT 1 FROM catalog WHERE id_product = p_id_product
        ) THEN
            -- Si ya existe, actualiza el descuento
            UPDATE catalog 
            SET discount = p_discount
            WHERE id_product = p_id_product;
        ELSE
            -- Si no existe, lo inserta en el catálogo
            INSERT INTO catalog (id_catalog, id_product, discount)
            VALUES (p_id_catalog, p_id_product, p_discount);
        END IF;
        
    END IF;
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_get_recipe_material(IN product_id INT)
BEGIN
    SELECT 
        rm.id_material AS ID_MATERIA, 
        rm.name AS NOMBRE_MATE
    FROM 
        raw_material rm
    WHERE 
        rm.id_state = 1
        AND rm.id_material NOT IN (
            SELECT r.id_material
            FROM recipe r
            WHERE r.id_product = product_id  -- Usamos el parámetro product_id
        );
END $$

DELIMITER ;


DROP PROCEDURE IF EXISTS sp_get_categories;
DELIMITER $$
CREATE PROCEDURE sp_get_categories()
BEGIN
    SELECT ID, NOMBRE FROM vw_active_categories;
END $$
DELIMITER ;


DELIMITER $$

DROP PROCEDURE IF EXISTS `sp_filter_products`$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_filter_products` (
    IN `p_searchTerm` VARCHAR(255),
    IN `p_category` VARCHAR(255)
)
BEGIN
    SELECT * FROM vw_active_products
    WHERE
        (
            (p_searchTerm IS NULL OR p_searchTerm = '')
            OR (nameProduct COLLATE utf8mb4_general_ci LIKE CONCAT('%', p_searchTerm COLLATE utf8mb4_general_ci, '%'))
            OR (description COLLATE utf8mb4_general_ci LIKE CONCAT('%', p_searchTerm COLLATE utf8mb4_general_ci, '%'))
        )
        AND (
            p_category IS NULL OR p_category = '' OR p_category = 'Todos'
            OR category COLLATE utf8mb4_general_ci = p_category COLLATE utf8mb4_general_ci
        );
END$$

DELIMITER ;


DELIMITER $$

-- Obtener perfil de usuario
DROP PROCEDURE IF EXISTS sp_get_user_profile$$
CREATE PROCEDURE sp_get_user_profile(IN p_user_id INT)
BEGIN
  SELECT 
    a.verified, 
    p.verified_phone,
    a.email AS USUARIO,
    p.first_name AS NOMBRES,
    p.last_name AS APELLIDOS,
    p.address AS DIRECCION,
    p.phone AS TELEFONO  
  FROM user_account a
  JOIN user_profile p ON a.id_user = p.id_user
  WHERE a.id_user = p_user_id;
END$$


DELIMITER $$

DROP PROCEDURE IF EXISTS sp_save_verify_token$$

CREATE PROCEDURE sp_save_verify_token(
    IN p_user_id INT,
    IN p_token VARCHAR(512)
)
BEGIN
    UPDATE user_account
    SET verify_token = p_token
    WHERE id_user = p_user_id;
END$$

DELIMITER ;


DELIMITER $$

DROP PROCEDURE IF EXISTS sp_update_user_profile$$

CREATE PROCEDURE sp_update_user_profile(
  IN p_user_id INT,
  IN p_nombres VARCHAR(255),
  IN p_apellidos VARCHAR(255),
  IN p_direccion VARCHAR(255),
  IN p_telefono VARCHAR(20)
)
BEGIN
  UPDATE user_profile
  SET first_name = p_nombres,
      last_name = p_apellidos,
      address = p_direccion,
      phone = p_telefono
  WHERE id_user = p_user_id;
END$$

DELIMITER ;


DELIMITER $$

-- Guardar código de verificación de teléfono
DROP PROCEDURE IF EXISTS sp_save_phone_verification$$

CREATE PROCEDURE sp_save_phone_verification(
  IN p_user_id INT,
  IN p_code VARCHAR(10)
)
BEGIN
  UPDATE user_profile
  SET phone_verification_code = p_code,
      verified_phone = 0
  WHERE id_user = p_user_id;
END$$

DELIMITER ;


DELIMITER $$

-- Verificar código de teléfono
DROP PROCEDURE IF EXISTS sp_verify_phone_code$$

CREATE PROCEDURE sp_verify_phone_code(
  IN p_user_id INT,
  IN p_code VARCHAR(10)
)
BEGIN
  DECLARE v_code VARCHAR(10);

  SELECT phone_verification_code 
  INTO v_code 
  FROM user_profile 
  WHERE id_user = p_user_id;

  IF v_code = p_code THEN
    UPDATE user_profile 
    SET verified_phone = 1, 
        phone_verification_code = NULL 
    WHERE id_user = p_user_id;

    SELECT 'success' AS result;
  ELSE
    SELECT 'invalid_code' AS result;
  END IF;
END$$

DELIMITER ;


-- Obtener pedidos del usuario
DROP PROCEDURE IF EXISTS sp_get_user_orders;
DELIMITER $$

CREATE PROCEDURE sp_get_user_orders(IN p_user_id INT)
BEGIN
  SELECT 
    oh.id_order AS ID_PEDIDO,
    oh.created_at AS fecha,
    os.name AS estado,
    oh.total_amount AS total,
    oh.total_discount AS descuento,
    JSON_ARRAYAGG(
      JSON_OBJECT(
        'nombre', p.name,
        'cantidad', od.quantity,
        'precio', od.final_price,
        'imagen', p.image_url
      )
    ) AS items
  FROM order_header oh
  JOIN order_status os ON oh.id_order_status = os.id_order_status
  JOIN order_detail od ON oh.id_order = od.id_order
  JOIN product p ON od.id_product = p.id_product
  WHERE oh.id_user = p_user_id
    AND oh.id_state = 1
  GROUP BY oh.id_order, oh.created_at, os.name, oh.total_amount, oh.total_discount
  ORDER BY oh.created_at DESC;
END$$

DELIMITER ;


-- Confirmar verificación de correo
DROP PROCEDURE IF EXISTS sp_confirm_email_verification;
DELIMITER $$
CREATE PROCEDURE sp_confirm_email_verification(
  IN p_user_id INT,
  IN p_token VARCHAR(512)
)
BEGIN
  DECLARE v_token VARCHAR(512);
  DECLARE v_verified TINYINT(1);
  DECLARE v_count INT DEFAULT 0;

  SELECT COUNT(*) INTO v_count FROM user_account WHERE id_user = p_user_id;

  IF v_count = 0 THEN
    SELECT 'invalid_token' AS result;
  ELSE
    SELECT verify_token, verified
      INTO v_token, v_verified
      FROM user_account
     WHERE id_user = p_user_id;

    IF v_verified = 1 THEN
      -- Si ya está verificado, aunque el token sea NULL, retorna already_verified
      SELECT 'already_verified' AS result;
    ELSEIF v_token IS NULL OR v_token <> p_token THEN
      SELECT 'invalid_token' AS result;
    ELSE
      UPDATE user_account SET verified = 1, verify_token = NULL WHERE id_user = p_user_id;
      SELECT 'success' AS result;
    END IF;
  END IF;
END$$
DELIMITER ;


DROP PROCEDURE IF EXISTS sp_save_reset_token;
DELIMITER $$

CREATE PROCEDURE `sp_save_reset_token`(
    IN `p_userId` INT, 
    IN `p_token` VARCHAR(512)
)
BEGIN
    UPDATE user_account
    SET reset_token = p_token,
        reset_token_expires = DATE_ADD(NOW(), INTERVAL 1 HOUR)
    WHERE id_user = p_userId;
END$$

DELIMITER ;


DROP PROCEDURE IF EXISTS sp_get_user_by_id;

DELIMITER $$

CREATE PROCEDURE sp_get_user_by_id(IN p_userId INT)
BEGIN
  SELECT * 
  FROM vw_active_find_user_by_id 
  WHERE ID_USUARIO = p_userId 
  LIMIT 1;
END $$

DELIMITER ;


DROP PROCEDURE IF EXISTS sp_toggle_user_state;
DELIMITER $$

CREATE PROCEDURE sp_toggle_user_state(
  IN p_id_user INT
)
BEGIN
  DECLARE v_current_state INT;

  -- Obtener el estado actual del usuario
  SELECT id_state INTO v_current_state
  FROM user_account
  WHERE id_user = p_id_user;

  -- Cambiar el estado (si 1 -> 2, si 2 -> 1)
  IF v_current_state = 1 THEN
    UPDATE user_account
    SET id_state = 2
    WHERE id_user = p_id_user;
  ELSEIF v_current_state = 2 THEN
    UPDATE user_account
    SET id_state = 1
    WHERE id_user = p_id_user;
  END IF;
END $$

DELIMITER ;


DROP PROCEDURE IF EXISTS sp_insert_massive_product_admin;
DELIMITER //
CREATE PROCEDURE sp_insert_massive_product_admin(
    IN p_id_product_type INT,
    IN p_name VARCHAR(30),
    IN p_price DECIMAL(10, 2),
    IN p_description VARCHAR(200),
    IN p_image_url VARCHAR(254),
    IN p_rating DECIMAL(3,1),
    IN p_warning VARCHAR(254)
)
BEGIN
    START TRANSACTION;

    INSERT INTO product (
        id_product_type,
        name,
        price,
        description,
        image_url,
        rating,
        warning
    )
    VALUES (
        p_id_product_type,
        p_name,
        p_price,
        p_description,
        p_image_url,
        p_rating,
        p_warning
    );

    COMMIT;
END //

DELIMITER ;


DELIMITER $$
CREATE PROCEDURE sp_activate_product_admin(IN p_id_product INT)
BEGIN
  UPDATE product SET id_state = 1 WHERE id_product = p_id_product;
END$$
DELIMITER ;



DROP PROCEDURE IF EXISTS sp_toggle_user_state;
DELIMITER $$

CREATE PROCEDURE sp_toggle_user_state(
  IN p_id_user INT
)
BEGIN
  DECLARE v_current_state INT;

  -- Comprobar si el usuario existe
  IF NOT EXISTS (SELECT 1 FROM user_account WHERE id_user = p_id_user) THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El usuario no existe.';
  END IF;

  -- Obtener el estado actual del usuario
  SELECT id_state INTO v_current_state
  FROM user_account
  WHERE id_user = p_id_user;

  -- Alternar entre los estados 1 y 2
  IF v_current_state = 1 THEN
    UPDATE user_account
    SET id_state = 2
    WHERE id_user = p_id_user;
  ELSEIF v_current_state = 2 THEN
    UPDATE user_account
    SET id_state = 1
    WHERE id_user = p_id_user;
  ELSE
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Estado de usuario no válido.';
  END IF;
  
  -- Confirmación (opcional, para indicar que la operación fue exitosa)
  SELECT 'Estado del usuario cambiado exitosamente' AS message;
  
END $$

DELIMITER ;

//procedimientos para ordenes

DELIMITER //

CREATE PROCEDURE UpdateOrderStatus(
    IN p_order_id INT,
    IN p_status_id INT
)
BEGIN
    UPDATE order_header
    SET id_order_status = p_status_id
    WHERE id_order = p_order_id AND id_state = 1;
END //

DELIMITER ;

////PROCEDIMIENTOS DE PRODUCCION Y SI, TIENE LLAVES COMPUESTAS

DELIMITER $$

CREATE PROCEDURE sp_insert_production(
    IN p_total_products INT,
    IN p_id_production_status INT
)
BEGIN
    INSERT INTO production (total_products, id_production_status)
    VALUES (p_total_products, p_id_production_status);

    SELECT LAST_INSERT_ID() AS id_production;
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_insert_production_detail(
    IN p_id_production INT,
    IN p_id_product INT,
    IN p_planned_quantity INT
)
BEGIN
    INSERT INTO production_detail (id_production, id_product, planned_quantity)
    VALUES (p_id_production, p_id_product, p_planned_quantity);
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_update_production_status(
    IN p_id_production INT,
    IN p_new_status INT
)
BEGIN
    -- Verificar si el nuevo estado es válido
    IF p_new_status NOT IN (600000, 600001) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid status. Only "En Producción" (600000) and "Finalizado" (600001) are allowed';
    END IF;

    -- Si el estado es "Finalizado" (600001), actualizar la fecha de fin
    IF p_new_status = 600001 THEN
        UPDATE production
        SET 
            id_production_status = p_new_status,
            end_datetime = NOW()  -- Registrar la fecha de finalización
        WHERE id_production = p_id_production AND id_production_status = 600000;  -- Solo si está en "En Producción"
        
        IF ROW_COUNT() = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Production not found or already finished';
        END IF;
    
    -- Si el estado es "En Producción" (600000), permitir volver a este estado desde "Finalizado"
    ELSEIF p_new_status = 600000 THEN
        UPDATE production
        SET 
            id_production_status = p_new_status,
            end_datetime = NULL  -- Limpiar la fecha de fin si se reactiva la producción
        WHERE id_production = p_id_production AND id_production_status = 600001;  -- Solo si está en "Finalizado"

        IF ROW_COUNT() = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Production not found or not finalized';
        END IF;
    END IF;
    
END $$

DELIMITER ;



DELIMITER $$

CREATE PROCEDURE sp_delete_production_detail(
    IN p_id_production INT,
    IN p_id_product INT
)
BEGIN
    UPDATE production_detail
    SET id_state = 3
    WHERE id_production = p_id_production AND id_product = p_id_product;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Production detail not found';
    END IF;
END $$

DELIMITER ;

//para validaciones produccion

DELIMITER $$

CREATE PROCEDURE sp_calculate_max_production(IN p_id_product INT)
BEGIN
    SELECT 
        r.id_product,
        p.name AS product_name,
        MIN(FLOOR(i.quantity / r.quantity_required)) AS max_producible
    FROM recipe r
    JOIN product p ON p.id_product = r.id_product
    JOIN inventory i ON i.id_material = r.id_material
    WHERE r.id_product = p_id_product
    GROUP BY r.id_product, p.name;
END$$

DELIMITER ;


//nunca se uso el siguiente SP - NUSP
DELIMITER $$

CREATE PROCEDURE sp_materials_needed(
    IN p_id_product INT,
    IN p_quantity INT
)
BEGIN
    SELECT 
        r.id_material,
        m.name AS material_name,
        (r.quantity_required * p_quantity) AS required,
        i.quantity AS available,
        GREATEST((r.quantity_required * p_quantity) - i.quantity, 0) AS missing
    FROM recipe r
    JOIN raw_material m ON m.id_material = r.id_material
    JOIN inventory i ON i.id_material = r.id_material
    WHERE r.id_product = p_id_product;
END$$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE sp_check_missing_materials (
    IN p_id_product INT,
    IN p_requested_qty INT
)
BEGIN
    SELECT 
        r.id_material,
        rm.name AS material_name,
        (r.quantity_required * p_requested_qty) AS required,
        IFNULL(i.quantity, 0) AS available,
        GREATEST((r.quantity_required * p_requested_qty) - IFNULL(i.quantity, 0), 0) AS missing
    FROM recipe r
    JOIN raw_material rm ON rm.id_material = r.id_material
    LEFT JOIN inventory i ON i.id_material = r.id_material
    WHERE r.id_product = p_id_product;
END$$

DELIMITER ;

//filtrado de productos con receta
DROP PROCEDURE IF EXISTS sp_get_products_with_recipe;
DELIMITER $$
CREATE PROCEDURE sp_get_products_with_recipe()
BEGIN
    SELECT DISTINCT
        p.id_product,
        p.name
    FROM product p
    INNER JOIN recipe r 
        ON p.id_product = r.id_product
    WHERE p.id_state = 1
      AND r.id_state = 1;
END$$
DELIMITER ;

DELIMITER $$

CREATE PROCEDURE sp_delete_production (
    IN p_id_production INT
)
BEGIN
    UPDATE production
    SET id_state = 3
    WHERE id_production = p_id_production;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Production not found';
    END IF;
END $$

DELIMITER ;


DELIMITER ;

DROP PROCEDURE IF EXISTS sp_find_user_by_email//

CREATE PROCEDURE sp_find_user_by_email(
IN `p_email` VARCHAR(100))
BEGIN
    SELECT 
        ua.id_user AS ID_USUARIO,
        ua.email AS USUARIO,
        ua.password AS PASSWORD,
        ua.id_state AS ESTADO,
        ur.id_role AS ID_ROL
    FROM
        user_account ua
    LEFT JOIN
        user_role ur ON ua.id_user = ur.id_user
    WHERE
        ua.email COLLATE utf8mb4_general_ci = p_email COLLATE utf8mb4_general_ci
        AND ua.id_state = 1
    LIMIT 1;
END //

DELIMITER ;



DELIMITER //

DROP PROCEDURE IF EXISTS sp_set_logged_in //

CREATE PROCEDURE sp_set_logged_in(
    IN p_user_id INT,
    IN p_is_logged_in BOOLEAN
)
BEGIN
    UPDATE user_account
    SET is_logged_in = p_is_logged_in
    WHERE id_user = p_user_id;
END //

DELIMITER ;


-------------------------------------TRIGGERS------------------------------------

DELIMITER //

CREATE TRIGGER trg_prevent_delete_role
BEFORE DELETE ON role
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from role is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_product_type
BEFORE DELETE ON product_type
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from product_type is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_material_type
BEFORE DELETE ON material_type
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from material_type is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_order_status
BEFORE DELETE ON order_status
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from order_status is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_production_status
BEFORE DELETE ON production_status
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from production_status is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_state
BEFORE DELETE ON state
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from state is not allowed. It is necessary for the correct functionality of the database.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_unit
BEFORE DELETE ON unit
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from unit is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_user_account
BEFORE DELETE ON user_account
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from user_account is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_user_role
BEFORE DELETE ON user_role
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from user_role is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_user_profile
BEFORE DELETE ON user_profile
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from user_profile is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_cart
BEFORE DELETE ON cart
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from cart is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_order_header
BEFORE DELETE ON order_header
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from order_header is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_inventory
BEFORE DELETE ON inventory
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from inventory is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_production
BEFORE DELETE ON production
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from production is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;

DELIMITER //

CREATE TRIGGER trg_prevent_delete_production_history
BEFORE DELETE ON production_history
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from production_history is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_inventory_history
BEFORE DELETE ON inventory_history
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from inventory_history is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_review
BEFORE DELETE ON review
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from review is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_order_detail
BEFORE DELETE ON order_detail
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from order_detail is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_recipe
BEFORE DELETE ON recipe
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from recipe is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_catalog
BEFORE DELETE ON catalog
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from catalog is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_product
BEFORE DELETE ON product
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from product is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_raw_material
BEFORE DELETE ON raw_material
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from raw_material is not allowed. Use id_state to deactivate.';
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_production_detail
BEFORE DELETE ON production_detail
FOR EACH ROW
BEGIN
  SIGNAL SQLSTATE '45000'
  SET MESSAGE_TEXT = 'Deleting records from production_detail is not allowed. Use id_state to deactivate.';
END;

//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_prevent_delete_inventory_movement_type
BEFORE DELETE ON inventory_movement_type
FOR EACH ROW
BEGIN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Deleting records from inventory_movement_type is not allowed. Use id_state to deactivate.';
END;

//

DELIMITER ;


/////////////////////////////////////////////NO LOS MISMOS//////////////////////////////////////////////////


DELIMITER $$

CREATE TRIGGER trg_update_product_rating
AFTER INSERT ON review
FOR EACH ROW
BEGIN
    -- Solo calcular promedio si el review insertado está activo
    IF NEW.id_state = 1 THEN
        CALL sp_calculate_average_rating(NEW.id_product);
    END IF;
END $$

DELIMITER ;


///TRIGGER CON LOGICA DE NEGOCIOS PENDIENTE POR REVISAR 
// Impide el funcionamiento del procedimiento por reglas de integridad de MySQL, hay que cambiar la lógica al back(trigger eliminado)
DELIMITER $$

CREATE TRIGGER trg_get_order_totals
AFTER INSERT ON order_detail
FOR EACH ROW
BEGIN
    CALL sp_calculate_order_totals(NEW.id_order);
END$$

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_inventory_insert
AFTER INSERT ON inventory
FOR EACH ROW
BEGIN
    INSERT INTO inventory_history (
        id_inventory,
        id_material,
        id_inventory_movement_type,
        quantity,
        id_state
    ) VALUES (
        NEW.id_inventory,
        NEW.id_material,
        5, -- ID de 'Creación'
        NEW.quantity,
        NEW.id_state
    );
END;

//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_inventory_update
AFTER UPDATE ON inventory
FOR EACH ROW
BEGIN
    DECLARE v_movement_type INT;

    IF NEW.quantity > OLD.quantity THEN
        SET v_movement_type = 6; -- ID de 'Ingreso'
        INSERT INTO inventory_history (
            id_inventory,
            id_material,
            id_inventory_movement_type,
            quantity,
            id_state
        ) VALUES (
            NEW.id_inventory,
            NEW.id_material,
            v_movement_type,
            NEW.quantity - OLD.quantity, -- Cantidad ingresada
            NEW.id_state
        );
    ELSEIF NEW.quantity < OLD.quantity THEN
        SET v_movement_type = 7; -- ID de 'Salida'
        INSERT INTO inventory_history (
            id_inventory,
            id_material,
            id_inventory_movement_type,
            quantity,
            id_state
        ) VALUES (
            NEW.id_inventory,
            NEW.id_material,
            v_movement_type,
            OLD.quantity - NEW.quantity, -- Cantidad salida
            NEW.id_state
        );
    END IF;
END;

//

DELIMITER ;

DELIMITER //

CREATE TRIGGER trg_production_detail_insert
AFTER INSERT ON production_detail
FOR EACH ROW
BEGIN
    INSERT INTO production_history (
        id_production,
        id_product,
        quantity,
        id_production_movement_type,
        id_state
    )
    VALUES (
        NEW.id_production,
        NEW.id_product,
        NEW.planned_quantity,
        1, -- 'Entrada'
        NEW.id_state
    );
END;
//

DELIMITER ;

DELIMITER //

CREATE TRIGGER trg_production_update
AFTER UPDATE ON production
FOR EACH ROW
BEGIN
    IF OLD.id_production_status <> NEW.id_production_status THEN
        IF NEW.id_production_status = 600000 THEN -- En Producción (reactivación)
            INSERT INTO production_history (
                id_production, id_product, quantity, id_production_movement_type, id_state
            )
            SELECT 
                NEW.id_production,
                pd.id_product,
                pd.planned_quantity,
                3, -- 'Reactivación'
                NEW.id_state
            FROM production_detail pd
            WHERE pd.id_production = NEW.id_production;

        ELSEIF NEW.id_production_status = 600001 THEN -- Finalizado
            INSERT INTO production_history (
                id_production, id_product, quantity, id_production_movement_type, id_state
            )
            SELECT 
                NEW.id_production,
                pd.id_product,
                pd.planned_quantity,
                2, -- 'Salida'
                NEW.id_state
            FROM production_detail pd
            WHERE pd.id_production = NEW.id_production;
        END IF;
    END IF;
END;
//

DELIMITER ;


DELIMITER //

CREATE TRIGGER trg_production_cancel
AFTER UPDATE ON production
FOR EACH ROW
BEGIN
    IF OLD.id_state <> NEW.id_state AND NEW.id_state = 3 THEN
        INSERT INTO production_history (
            id_production, id_product, quantity, id_production_movement_type, id_state
        )
        SELECT 
            NEW.id_production,
            pd.id_product,
            pd.planned_quantity,
            4, -- ID de 'Cancelación'
            NEW.id_state
        FROM production_detail pd
        WHERE pd.id_production = NEW.id_production;
    END IF;
END;
//





